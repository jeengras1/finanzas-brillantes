/**
 * üìà M√ìDULO 1 ‚Äì Ganancias V6.1
 * L√≥gica optimizada: inversi√≥n por oportunidad, reinversi√≥n, stop-loss din√°mico, rotaci√≥n de activos, sin l√≠mite arbitrario de precio.
 */

// üì¶ Obtener credenciales
function obtenerCredencialesAlpaca() {
  const hoja = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("Configuraci√≥n");
  if (!hoja) throw new Error("‚ùå Falta hoja 'Configuraci√≥n'");
  const datos = hoja.getRange("A1:B100").getValues();
  const cred = {};
  datos.forEach(([k, v]) => { if (k && v) cred[k.trim()] = v.toString().trim(); });
  return {
    endpoint: cred["alpaca_endpoint"],
    apiKey: cred["alpaca_api_key"],
    apiSecret: cred["alpaca_secret_key"],
    telegram_token: cred["telegram_token"],
    telegram_chat_id: cred["telegram_chat_id"]
  };
}

// üì≤ Enviar alerta a Telegram
function enviarTelegram(msg) {
  try {
    const { telegram_token, telegram_chat_id } = obtenerCredencialesAlpaca();
    if (!telegram_token || !telegram_chat_id) return;
    const url = `https://api.telegram.org/bot${telegram_token}/sendMessage`;
    UrlFetchApp.fetch(url, {
      method: "post",
      contentType: "application/json",
      payload: JSON.stringify({ chat_id: telegram_chat_id, text: msg })
    });
  } catch (e) { Logger.log("‚ö†Ô∏è Telegram fall√≥: " + e); }
}

// üì¶ Consultar portafolio Alpaca
function consultarPortafolioAlpaca() {
  const { endpoint, apiKey, apiSecret } = obtenerCredencialesAlpaca();
  const res = UrlFetchApp.fetch(`${endpoint}/positions`, {
    method: "get",
    headers: {
      "APCA-API-KEY-ID": apiKey,
      "APCA-API-SECRET-KEY": apiSecret
    },
    muteHttpExceptions: true
  });
  return JSON.parse(res.getContentText());
}

// üìä Obtener o crear hoja con encabezados
function obtenerHojaOcrear(nombre, encabezados = []) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let hoja = ss.getSheetByName(nombre);
  if (!hoja) hoja = ss.insertSheet(nombre);
  if (encabezados.length && hoja.getLastRow() === 0) hoja.appendRow(encabezados);
  return hoja;
}

// üßÆ Porcentaje din√°mico de stop-loss seg√∫n capital
function obtenerPorcentajeStopLoss(capital) {
  if (capital < 20) return 0.03;
  if (capital < 50) return 0.025;
  if (capital < 100) return 0.02;
  if (capital < 300) return 0.015;
  if (capital < 1000) return 0.01;
  return 0.005;
}

// üöÄ Detectar y registrar ganancias
function registrarGananciasYActualizarCapital() {
  const posiciones = consultarPortafolioAlpaca();
  const hojaHistorial = obtenerHojaOcrear("Historial", ["Fecha", "Activo", "Qty", "Precio", "Valor", "Ganancia", "Fuente"]);
  const hojaCapital = obtenerHojaOcrear("CapitalDisponible", ["Fecha", "Monto Disponible"]);
  const hojaLog = obtenerHojaOcrear("üìÖ Log Ganancias", ["Fecha", "Ganancia Neta", "Capital Final"]);
  const hojaResumen = obtenerHojaOcrear("üìä Resumen Ganancias", ["Campo", "Valor"]);

  const fecha = new Date();
  let gananciaTotal = 0;
  let capitalActual = 0;

  posiciones.forEach(pos => {
    const ganancia = parseFloat(pos.unrealized_pl);
    const valor = parseFloat(pos.market_value);
    const activo = pos.symbol;
    const precio = parseFloat(pos.current_price);
    const qty = parseFloat(pos.qty);
    capitalActual += valor;

    const hojaYaTiene = hojaHistorial.getRange(2, 1, hojaHistorial.getLastRow(), 2).getValues()
      .some(fila => fila[0]?.toString().includes(fecha.toDateString()) && fila[1] === activo);

    if (!hojaYaTiene && Math.abs(ganancia) >= 0.01) {
      const fuente = ganancia >= 0 ? "üìà Ganancia Detectada" : "üìâ P√©rdida Detectada";
      hojaHistorial.appendRow([fecha, activo, qty, precio, valor, ganancia, fuente]);
      gananciaTotal += ganancia;
    }

    // Stop-loss din√°mico
    const porcentaje = obtenerPorcentajeStopLoss(capitalActual);
    const umbral = -1 * valor * porcentaje;
    if (ganancia <= umbral) {
      enviarTelegram(`‚ö†Ô∏è Stop-loss ejecutado: ${activo} con p√©rdida de $${ganancia.toFixed(2)} (${(porcentaje * 100).toFixed(2)}%)`);
    }
  });

  hojaCapital.appendRow([fecha, capitalActual]);
  hojaLog.appendRow([fecha, gananciaTotal, capitalActual]);
  hojaResumen.getRange(2, 1, 3, 2).setValues([
    ["Ganancia Total", gananciaTotal.toFixed(2)],
    ["Capital Final", capitalActual.toFixed(2)],
    ["√öltima Fecha", fecha.toLocaleString()]
  ]);

  if (gananciaTotal !== 0) {
    enviarTelegram(`‚úÖ *Ganancia Neta:* $${gananciaTotal.toFixed(2)}\nüíº *Capital Final:* $${capitalActual.toFixed(2)}\nüïí ${fecha.toLocaleString()}`);
    try { ejecutarReinversionAutomatica(); } catch (e) {
      Logger.log("‚ö†Ô∏è Reinversi√≥n no ejecutada: " + e);
    }
  }
}

// üîç Buscar oportunidades reales sin l√≠mite de precio
function ejecutarSimulacionDemoFase1() {
  Logger.log("üéØ Buscando oportunidades...");
  const hoja = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("Activos");
  if (!hoja) return Logger.log("‚ùå Falta hoja 'Activos'");

  const { apiKey, apiSecret } = obtenerCredencialesAlpaca();
  const activos = hoja.getRange("A2:A").getValues().flat().filter(Boolean);

  const oportunidades = activos.map(simbolo => {
    try {
      const url = `https://data.alpaca.markets/v2/stocks/${simbolo}/quotes/latest`;
      const res = UrlFetchApp.fetch(url, {
        headers: { "APCA-API-KEY-ID": apiKey, "APCA-API-SECRET-KEY": apiSecret }
      });
      const data = JSON.parse(res.getContentText());
      const precio = parseFloat(data?.quote?.ap || data?.quote?.bp);
      return precio > 0 ? { simbolo, precio } : null;
    } catch {
      return null;
    }
  }).filter(Boolean);

  const hojaCapital = obtenerHojaOcrear("CapitalDisponible");
  const capital = parseFloat(hojaCapital.getRange(hojaCapital.getLastRow(), 2).getValue() || "0");
  const porActivo = capital / oportunidades.length;

  oportunidades.forEach(({ simbolo, precio }) => {
    const cantidadPosible = porActivo / precio;
    if (cantidadPosible >= 0.01) {
      Logger.log(`‚úÖ Oportunidad: ${simbolo} ‚Äì Precio: $${precio} ‚Äì Puede comprar: ${cantidadPosible.toFixed(4)} unidades`);
    }
  });
}

// üß† Ejecutar m√≥dulo completo
function ejecutarModuloGanancias() {
  try {
    Logger.log("üöÄ Ejecutando m√≥dulo de ganancias...");
    ejecutarSimulacionDemoFase1();
    registrarGananciasYActualizarCapital();
    Logger.log("‚úÖ M√≥dulo completado.");
  } catch (e) {
    Logger.log("‚ùå Error: " + e);
    enviarTelegram("‚ùå Error en m√≥dulo de ganancias:\n" + e.message);
  }
}

// üìÑ Documentar m√≥dulo
function documentarModuloGanancias() {
  const hojaDoc = obtenerHojaOcrear("üìÑ Modulo 1 - Ganancias", ["Campo", "Descripci√≥n"]);
  hojaDoc.getRange(2, 1, 6, 2).setValues([
    ["Nombre", "üìà M√≥dulo 1: Ganancias ‚Äì V6.1"],
    ["Funci√≥n", "Detecta oportunidades, calcula ganancias, aplica stop-loss y reinvierte"],
    ["Modo", "Demo (Paper Trading)"],
    ["Trigger", "Autom√°tico cada hora"],
    ["√öltima actualizaci√≥n", new Date()],
    ["Estado", "‚úÖ Activo"]
  ]);

  const hojaLista = obtenerHojaOcrear("üìÇ Lista Scripts .gs", ["Nombre Script", "Funci√≥n", "Fecha", "Estado"]);
  hojaLista.appendRow(["ModuloGanancias.gs", "L√≥gica completa de ganancias + oportunidades", new Date(), "‚úÖ Activo"]);
}

// ‚è± Activar trigger autom√°tico
function instalarTriggerGanancias() {
  ScriptApp.getProjectTriggers().forEach(t => {
    if (t.getHandlerFunction() === "ejecutarModuloGanancias") ScriptApp.deleteTrigger(t);
  });
  ScriptApp.newTrigger("ejecutarModuloGanancias").timeBased().everyHours(1).create();
  Logger.log("‚è± Trigger instalado");
}

// üß† Inicializar todo
function inicializarModuloGanancias() {
  ejecutarModuloGanancias();
  documentarModuloGanancias();
  instalarTriggerGanancias();
}